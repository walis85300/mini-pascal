package Tiny;

import java_cup.runtime.*;
import ast.*;
//import otros.*;

parser code {:

/***********
SymbolFactory es una nueva caracteristica que ha sido a�adida a las version 11a de cup, la cual facilita la implementacion de clases Symbol personalizadas
, esto debido a que dicha clase no provee mucha informaci�n de contexto que podria ser util para el analisis semantico o ayudar en la construccion del AST
Mas informacion en: http//4thmouse.com/index.php/2007/02/15/using-custom-symbols-in-cup/
***********/
	public static void main(String args[]) throws Exception {
		SymbolFactory sf = new DefaultSymbolFactory();
		parser parser_obj;
		if (args.length==0) 
			parser_obj=new parser(new Scanner(System.in,sf),sf);
		else 
			parser_obj=new parser(new Scanner(new java.io.FileInputStream(args[0]),sf),sf);

		parser_obj.parse();
		/*NodoBase root=parser_obj.action_obj.getASTroot();
		System.out.println();
		System.out.println("IMPRESION DEL AST GENERADO");
		System.out.println();
		ast.Util.imprimirAST(root);
		TablaSimbolos ts = new TablaSimbolos();
		ts.cargarTabla(root);
		ts.ImprimirClaves();
		Tiny.Generador.setTablaSimbolos(ts);
		Tiny.Generador.generarCodigoObjeto(root);*/
	}

:}

action code {:
	private boolean debug=true;
	private NodoBase ast=null;
	private int lineanum=0;
	
	//Debe ser llamada solo despues de un parse(), en caso contrario retornara null siempre;
	public NodoBase getASTroot(){
		return ast;
	}
	
:}

/* Simbolos Terminales */

terminal IF;
terminal THEN;
terminal ELSE;
terminal END;
terminal REPEAT;
terminal WHILE;
terminal DO;
terminal UNTIL;
terminal READ;
terminal WRITE;
terminal String ID;
terminal String NUM;
terminal ASSIGN;
terminal EQ;
terminal LT;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal OVER;
terminal LPAREN;
terminal RPAREN;
terminal SEMI;
terminal BEGIN;
terminal AND;
terminal OR;
terminal LQ;
terminal GT;
terminal GQ;
terminal NQ;
terminal FOR;
terminal VAR;
terminal PROGRAM;
terminal COL;
terminal INTEGER;
terminal BOOLEAN;
terminal ARRAY;
terminal OF;
terminal DOT;
terminal COMMA;
terminal LB;
terminal RB;
terminal FUNCTION;
terminal TO;

/* Simbolos No Terminales */
non terminal program;
non terminal NodoBase declaraciones;
non terminal NodoBase stmt;
non terminal NodoBase if_stmt;
non terminal NodoBase repeat_stmt;
non terminal NodoBase while_stmt;
non terminal NodoBase assign_stmt;
non terminal NodoBase read_stmt;
non terminal NodoBase write_stmt;
non terminal NodoBase exp;
non terminal NodoBase simple_exp;
non terminal NodoBase term;
non terminal NodoBase factor;
non terminal begin;
/* Nuestros no terminales */
non terminal programa;
non terminal cuerpo;
non terminal var_dec_p;
non terminal var_dec;
non terminal dec;
non terminal type;
non terminal simp_type;
non terminal arr_type;
non terminal ind_range; 
non terminal func_dec_p;
non terminal argumentos;
non terminal stm;
non terminal lista_declaraciones;
non terminal for_stmt;
non terminal oplog;
non terminal args_stmt;

/* Precedencia de operadores */
precedence left PLUS;
precedence left MINUS;
precedence left TIMES;


/* REGLAS GRAMATICALES */

program ::= PROGRAM ID SEMI cuerpo  {: 

					if(debug) System.out.println("\t regla 1");
			
				:}
			;
			
cuerpo ::= var_dec_p func_dec_p stm  {:	
	if(debug) System.out.println("\t declaracion de variables");		
	:}
	;
	
var_dec_p ::= VAR var_dec_p SEMI  {: if (debug) System.out.println("\t declara variable regla 3.1"); :}
			| var_dec_p SEMI  var_dec   {: if (debug) System.out.println("\t declara variable  regla 3.2"); :}
			| var_dec   {: if (debug) System.out.println("\t declara variable regla 3,3");:} 
			;
						
func_dec_p ::= FUNCTION simp_type ID:nf argumentos stm {:
				 if (debug) System.out.println("\t Declaracion de la funcion"+nf);
				 :}
				 ;		
				 
argumentos ::= LPAREN var_dec RPAREN {:
				if (debug) System.out.println("\t regla 8 Argumentos");
				:}
				| LPAREN RPAREN {:
					if (debug) System.out.println("\t funcion sin parametros");
					:}			
				;		
				
stm ::= BEGIN lista_declaraciones END SEMI {:
					System.out.println("\t lista de declaraciones");
				:}	
				;				
				
lista_declaraciones ::= declaraciones  {:
					if (debug) System.out.println("\t Regla 1 declaraciones");
				:} 
				|
				lista_declaraciones declaraciones {:
					if (debug) System.out.println("\t Regla 2 declaraciones");
				:}	
				; 

				

var_dec	 ::= var_dec COMMA dec {:
				if (debug) System.out.println("\t regla 4.2");
			:}
			|
			dec {:
				if (debug) System.out.println("\t regla 4.1"); 
			:}			
			;
			
dec 	::= dec COL type  {:
				if (debug) System.out.println("\t regla 5.2");
			:}
			| 
			ID:nombre {:
				if (debug) System.out.println("\t nombre de variable: "+nombre);		 
			:}
			;				
								

type	::= simp_type {:
				if (debug) System.out.println("\t regla 6.1");				
			:} 
			| arr_type {:
				if (debug) System.out.println("\t regla 6.2");
			:}
			;
			

arr_type ::= ARRAY LB ind_range RB OF simp_type	{:
				if (debug) System.out.println("\t regla 7");
			:} 
			;

simp_type ::= INTEGER {:
					if (debug) System.out.println("type Integer");
				:} 
				| BOOLEAN {:
					if (debug) System.out.println("type Boolean");
				:} 
				;

ind_range ::= NUM:ni DOT DOT NUM:nd {:
					if (debug) System.out.println("Array entre"+ni+" "+nd);
				:}
				;		
declaraciones        ::= if_stmt:sif	{: if(debug) System.out.println("\t regla 3a"); 
					:}
            | repeat_stmt:srep	{: if(debug) System.out.println("\t regla 3b"); 
						:}
		    | while_stmt:wrep	{: if(debug) System.out.println("\t regla 3f"); 
						:}
			| for_stmt {: if (debug) System.out.println("\t regla del for"); :}
            | assign_stmt:sasi SEMI	{: if(debug) System.out.println("\t regla 3c"); 
						:}
            | read_stmt:slec SEMI	{: if(debug) System.out.println("\t regla 3d"); 
					:}
            | write_stmt:sesc SEMI	{: if(debug) System.out.println("\t regla 3e"); 
					:}
            | error	{: if(debug) System.out.println("\t regla 3f"); 
				System.out.println("Ocurrio error en cup # 0004");
				:}
            ;

if_stmt     ::= IF exp:ex THEN stm:pthen END SEMI	{: if(debug) System.out.println("\t regla 4a"); 
		:}
		| IF exp:ex THEN declaraciones:pthen ELSE declaraciones:pelse END SEMI	{: if(debug) System.out.println("\t regla 4b"); 
		:}
		;

repeat_stmt ::= REPEAT lista_declaraciones:cuerpo UNTIL exp:prueba	{: if(debug) System.out.println("\t regla 5"); 
							:}
		;
		
while_stmt ::= WHILE exp:prueba DO stm:cuerpo	{: if(debug) System.out.println("\t regla 5w"); 
							:}
		;		


for_stmt ::= FOR assign_stmt TO NUM DO stm {:
				if (debug) System.out.println("\t declaracion del for");
			:}
			;		

assign_stmt ::= ID:variable 	{: if(debug) System.out.println("\t regla 6 parte del medio"); 
				/*lineanum=1000; //Pasar/Obtener la linea correcta por el Simbolo
				String nombre = variable.getName();*/
				:}
			ASSIGN exp:ex	{: if(debug) System.out.println("\t regla 6 parte final");
					
					:}
		;

read_stmt   ::= READ ID:variable	{: if(debug) System.out.println("\t regla 7"); 
					System.out.println("Leyendo Variable");
					:}
		;

write_stmt  ::= WRITE exp:ex	{: if(debug) System.out.println("\t regla 8"); 
					:}
		;

exp         ::= simple_exp:exI LT simple_exp:exD	{: if(debug) System.out.println("\t regla 9a"); 
								:} 
		| simple_exp LQ simple_exp {: if (debug) System.out.println("\t regla 9d"); :}
		| simple_exp GT simple_exp {: if (debug) System.out.println("\t regla 9e");	:}
		| simple_exp GQ simple_exp {: if (debug) System.out.println("\t regla 9f"); :}	
		| simple_exp NQ simple_exp {: if (debug) System.out.println("\t regla 9h"); :}					
		| simple_exp:exI EQ simple_exp:exD	{: if(debug) System.out.println("\t regla 9b"); 
							:}
		| simple_exp:ex	{: if(debug) System.out.println("\t regla 9c"); 
					:}
		| exp oplog factor {: if (debug) System.out.println("\t regla 9g"); :}	
		;

oplog ::= OR {: if (debug) System.out.println("\t operador or"); :}
		 |
		 AND {: if (debug) System.out.println("\t operador and"); :}
		 ;
		 
args_stmt ::= exp COMMA args_stmt {:
				if (debug) System.out.println("\t argumentos");
			:}
			|
			exp {:
				if (debug) System.out.println("\t argumento");
			:}
			;


simple_exp  ::= simple_exp:exI PLUS term:exD	{: if(debug) System.out.println("\t regla 10a"); 
							:}
		| simple_exp:exI MINUS term:exD	{: if(debug) System.out.println("\t regla 10b"); 
							:}
		| term:ex	{: if(debug) System.out.println("\t regla 10c"); 
				RESULT=ex;
				:}
		;

term        ::= term:exI TIMES factor:exD	{: if(debug) System.out.println("\t regla 11a"); 
							:}
		| term:exI OVER factor:exD	{: if(debug) System.out.println("\t regla 11b"); 
						:}
		| factor:ex	{: if(debug) System.out.println("\t regla 11c"); 
					:}
		;

factor      ::= LPAREN exp:ex RPAREN	{: if(debug) System.out.println("\t regla 12a"); 
							:}
		| NUM:valor	{: if(debug) System.out.println("\t regla 12b"); 
					System.out.println("Devolvi nodo numero entero");
					:}
		| ID:variable	{: if(debug) System.out.println("\t regla 12c"); 
					:}
		| error	{: if(debug) System.out.println("\t regla 12d"); 
				:}
		| ID:nom LPAREN RPAREN {: if (debug) System.out.println("\t regla 12e"); :}
		| ID:nom LPAREN args_stmt RPAREN {: if (debug) System.out.println("\t regla 12f"); :}
		;					
				